---
aliases: []
---
```py

```

Apache Cassandra - NoSQL распределенная база данных.

#### Распределенность
Можно установить на одну ноду, анпример на ноут, но так используется редко. Мощность примерно 3000 транзакций/сек/ядро. Однако ее мощь можно увидеть только при установке на несколько серверов.

Cassandra - masterless система, т.е.у нее нет головнной ноды и нод-слейвов. Это работает на **отказоустойчивость**. Не имеет единой точки отказа (нет master ноды). У каждой ноды те же обяханности, что и у всех остальных. Также все ноды взаимодейсвтвуют друг с другом.
![](https://i.imgur.com/BKNOnY8.png)

#### Особенности Cassandra
* Распределенная
	* Короткое время отклика
	* Масштабируемая
* Реплецируемая (реплицировать - создвавть синхронную копию)
	* Высокая отказоустойчивость
* Masterless система
* Настраиваемая консистентность (Консистентность — это согласованность, целостность, последовательность и непротиворечивость элементов в интерфейсе.)

**Распределенность и доступность.**
1. Ноды организованы в кольцо.
2. Ноды мониторят состояние друг друга.
3. Кассандра перенаправляет запросы так, чтобы их не получали медленные и вышедшие из строя ноды. Данные будут доставлены, когда нода "придет в себя".

**Горизонтальное и вертикальное масштабирование.**
Вертикальное - увеличение мощности сервер. Но это дорого.
Горизонтальное - увеличение количества серверов.

Кассандра масштабируется линейно.

**Распределенность и реплецированность.**
На основе partition key (ключ раздела) записи будут поделены между разными нодами.
![](https://i.imgur.com/isreobR.png)

Помимо распределенности есть еще репелецированность, т.е. дублирование записей на несколько нод.
![](https://i.imgur.com/2XWvLwY.png)

Еще одна особенность - географическая распределенность. За счет реплекации данных по кластерам, данные могут быть распределены по разным точкам мира.
![](https://i.imgur.com/Nzb5V5P.png)
Дополнительно это дает географичческую близость к клиенту.
Также Кассандра позволяет указывать явно в каком именно дата-центре могут лежать те или иные данные.


## Модель данных
![](https://i.imgur.com/WKbjjCN.png)
- *Keyspace* содержит таблицы, аналог БД.
- *Таблицы* организованны в столбцы и колонки.
- Группы связанных строк называются *партициями* и хранятся вместе на одной ноде.
- Каждая строка имеет свой *партиционный ключ*.

### Создание таблиц
Создается с помощью CQL - cassandra query lenguage:
```cql
CREATE TABLE employee(
	department text,
	full_name text,
	age int,
	PRIMARY KEY ((department), full_name)
)
```
department = partition key,
full_name = clusterung column (optional) 
PRIMARY KEY должен быть уникальным.

## Token ring и репликация данных

Предположим, что наша таблицы распределенно хранится на нескольких нодах (кольце нод). Новые данные могут прийти на любую ноду. Для того, чтобы распределить их в правильную (к свой партиции) необходимо:
1) узнать где находятся необходимые данные, к какому серверу их отправлять;
2) координатор-нода (та на которую поступил новый запрос с данными) берет partition key из запроса, высчитывает **хэш** и согласно имеющеймся у нее данным понимает, какие сервера ответсвенны за этот диапозон.
3) Нода, ответсвенная за пришедшие данные называется Replica node.

![](https://i.imgur.com/yPRqaHv.png)

Что происходит, когда одна из ответсвенных нод не может быть обновлена?
1. hinted handoff. Когда данные не могут быть доставлены на одну из соответсвующих нод, нода-координатор сохраняет это как файл, и как только она узнает, что упавшая нода восстановлена, он передаст данные на нее.
2. Если первый вариант невозможен, по причине длительного падения, то рекомендуется вывести упавшую ноду из кольца и ввести ее обратно как новую. Это будет дольше, но гарантирует консистентность данных.

В случае нескольких дата-центров, нода-координатор передает любой из нод в другом ДЦ данные, эта нода будет называться remote coordinator node. Далее она дейсвтиет аналогично описанному выше поведению.
![](https://i.imgur.com/eK1jvjF.png)


## Консистентность
**Теорема** CAР (известная также как **теорема** **Брюера**) — эвристическое утверждение о том, что в любой реализации распределённых вычислений возможно обеспечить не более двух из трёх следующих свойств: согласованность данных (англ. consistency) — во всех вычислительных узлах в один момент времени данные не противоречат друг другу.
![](https://s3.amazonaws.com/geekbrains-uploads/geekbrains/public/ckeditor_assets/pictures/2486/content_hx8h0.png)

**Consistency Levels (CL)**
Устанавливается на каждый запрос. Его дефолтное значение - кворум.
Если установлено CL =1, то как только одна из нод ответила, что она получила запрос, координатор нода считает, что запрос успешно передан и сообщает об этом клиенту.
![](https://i.imgur.com/g5delst.png)

Quorum = (all replica nodes/2) + 1

CL=all - дожидаемся подтверждения от всех реплика-нод. В этому случае достигается волная консистентность в ущерб доступности.

LOCAL_QUORUM - используется в случае с несколькими ДЦ. В этом случае будут ожидаться подтверждение от кворума нод только локального ДЦ. В то время как QUORUM в этом случае означает кворус ото всех ДЦ. Это не выгодно.


### Концепция доступности
- RP (replication factor) - количество копий данных.
	- увеличение количества -> увеличение доступности
	- увеличение количества -> уменьшение конситстентности

-  CL (Consistency Level) - количество подтверждений для записи или для чтения. Сколько нод сохранило запись/сообщило одни и те же данные
-  Immediate Consistency: CL на запись + CL на чтение > RF

Пример:
RF = 3
Read/Write CL = QUORUM
2 + 2 = 4 > 3

### Настройки консистентности

От слабой к сильной
- ANY - как только запрос достиг координатора, он считается обработанным. Максимальная производительность, велика вероятность неконсистентрости.
- ONE, TWO, THREE - ближайшие ноды к коотдинатору должны ответеть в указанном количестве.
- QUORUM - большенство реплика-нод (половина + 1)
- LOCAL_ONE - ближайшая нода к координатору (или он сам, если является реплика-нодой) в ближайшем ДЦ.
- LOCAL_QUORUM - местное большинство.
- EACH_QUORUM - кворум на запись в каждом ДЦ.
- ALL - все реплика-ноды должны ответить.

При написании запроса необходимо решить, какая консистентность требуется. 

## CQL - Cassandra Query Language
Создание Keyspace:
```CQL
CREATE KEYSPACE users
	WITH REPLECATION = {
	'class' : 'NetworkTopologyCtrategy',
	'datacenter1' : 3
	}
```
![](https://i.imgur.com/hlc5KSs.png)

Создание таблицы:
```CQL
CREATE TABLE users.user_by_city (
	city text,
	Last_name text,
	first_name text,
	address text,
	email text,
	PRIMARY KEY ((city), last_name, first_name)
	)
```
![](https://i.imgur.com/GJIoWa1.png)


## Запись данных
Когда запрос на запись приходит в ноду, данные сначала идут на диск, в коммит лог (простой файл только на запись). В идеале коммит лог больше не будет использоваться никогда. Потом данные идут в память. Как только данные попали в коммит лог, мы сразу отсылаем aknolagement - ок, данные сохранены.
![](https://i.imgur.com/O3AL4Xj.png)

Приходят следующие записи. Стоит обратить внимание, что запись коммит лога и запись таблицы отличаются:
![](https://i.imgur.com/5XouYgt.png)
Отилчаются они порядком. В коммит лог данные попадают по мере добавления, а в таблицу по разделу, сортировка будет осуществляться в алфавитном порядке.

По окончании процесса записи, таблица сохраняется на диск и коммит лог удаляется. Далее следует операция мержа тиблиц на диске воедино.
![](https://i.imgur.com/pwPtbXv.png)

## Чтение данных
![](https://i.imgur.com/xW23KvX.png)
![](https://i.imgur.com/Q8NIglz.png)

