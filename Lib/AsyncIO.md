---
aliases: [AsyncIO, асинхронность]
---
```py

```
# Асинхронное программирование в Python

## Немного освежим знания
- у процессора может быть несколько ядер. Когда вычисления производятся на разных ядрах - это параллельные вычисления. 
- у системы ос есть так называемые системные треды. Threads они аллокируются питоном у самой системы и довольно много весят + сам процесс аллокирования очень медленный с точки зрения компьютера. Ниже пример использования библиотеки `threading`. Которая направлена на аллокирование треда у системы и выполнения какой-то операции внутри него. Есть еще библиотека [concurrent.futures](https://docs-python.ru/standart-library/modul-concurrent-futures-python/), которая делает все проще, но это не тема текущего урока.
```py
from threading import Thread

def square_numbers():
    for i in range(1000):
        result = i * i
        print(result)

        
threads = []
num_threads = 10

# аллокируем у системы 10 тредов, которые будут выполнять функцию
# square_numbers
for i in range(num_threads):
    thread = Thread(target=square_numbers)
    threads.append(thread)

# начинаем выполнение функций в каждом треде
for thread in threads:
    thread.start()

# начинаем ожидать пока все треды закончат выполнение 
# при этом главный тред, в котором выполняется весь этот код
# блокируется пока не закончат выполнение всех тредов
for thread in threads:
    thread.join()
```

## asyncIO
### зачем понадобилось что-то еще?
Можно задаться вопросом, зачем понадобилось что-то еще, если уже есть трединг и разделение работы между отдельными тредами? 
Ответ заключается в том, что:
- asyncio быстрее, так как не надо аллокировать системный тред для каждой новой работы. Ниже график скорости работы двух подходов из этой [статьи](https://towardsdatascience.com/a-better-way-for-asynchronous-programming-asyncio-over-multi-threading-3457d82b3295)
![](https://i.imgur.com/4G88zll.png)
- использование asyncio эффективнее по памяти. 
- в asyncio больше контроля за процессом выполнения работ.  

### Как это работает?
Начиная с питона 3.7 asyncIO - это стандартная библиотека питона, это означает, что ничего дополнительно устанавливать не надо. Достаточно просто импортировать библиотеку, для того, чтобы начать с ней работать. 

В работе с асинхронным программированием на питоне связано связано несколько особенностей:

> __Первая особенность__ - Для того, чтобы запустить какую либо функцию в асинхронном режиме, необходимо написать перед ней ключевое слово `async`. 
```py
import asyncio

async def main():
    print("hello")

main()
```
Если запустить пример выше, то в Out выведется что-то типа:  
`<coroutine object main at 0x7fc3483227c0>`  
Это приводит нас ко второй особенности: 
> __Вторая особенность__ - теперь функция возвращает объект `coroutine`, вместо значения, которое ожидалось. 

На том, что такое coroutine следует остановиться подробнее.  
__Coroutine__ - или на русском их еще называют сопрограмма - это обертка над функцией, которая добавляет множество точек входа и выхода (передачи управления процессингом) в нее. То есть если обычная функция начинает скачивание картинки из интернета, она не отдаст ресурс (внимание интерпретатора) до тех пор пока не скачает картинку и не перейдет на return строчку. А корутина, дойдет до строчки, где начинается скачивание картинки и отдаст ресурс интерпретатора, до момента скачки картинки, чтобы он мог заняться другими вещами. Станет понятнее когда мы посмотрим пример, чуть позже.  

Представим себе, что мы поняли, что такое сопрограмма и двинемся дальше.

Итак нам из функции теперь вернулся объект coroutine. Но нам нужно значение функции, а не этот объект. Как же нам его получить?

> __Третья особенность__ - Объекты корутины - это еще и задачи или ивенты, которые только заполнены для выполнения, но фактически их выполнение еще не началось. Чтобы выполнить корутину нужен специальный механизм, который называется event loop. 

Чтобы создать `event loop` в бибилиотеке есть специальный метод         `asyncio.new_event_loop()`
```py
import asyncio
asyncio.new_event_loop()
```

У event loop - loop в названии не случайно, потому что это цикл опроса событий. Нам не нужно вдаваться в подробности реализации этого механизма. Важно просто знать, что это служебная часть, которая позволяет опрашивать, регистрировать и передавать управления среди всех корутин. То есть ивент луп, знает о том, какие корутины существуют и за один цикл обхода проходится по каждой из них и смотрит какая из корутин готова отдать ресурс, потому что пока что простаивает, а какая нуждается в этом ресурсе, чтобы продолжить свое выполнение. 

> __Важно__, отметить, что у asyncio есть например еще метод run, который принимает корутину на вход и отдает результат ее выполнения, но в jupyter все несколько сложнее, потому, что тут уже запущен ивент луп,поэтому создать свой хоть и получается в примере выше, но вот передать ему что-то на выполнение нет)) Ниже пример как можно запустить корутину в пайчарме:
![](https://i.imgur.com/LDwI50K.png)

Чтобы каждый раз не обращаться к объекту event loop и не вызывать у него метод `run_until_complete` придумали синтаксический сахар в виде ключевого слова `await`
> __Четвертая особенность__, когда мы хотим дождаться конца выполнения какой либо корутины, мы должны написать ключевое слово `await` (ожидай).
```py
import asyncio

async def main():
    print("hello")

await main()
```
Следует отметить, что await - блокирует интерпретатор, до тех пор пока корутина не доработает.
```py
async def main():
    print("hello")
    await foo("world")
    print("finished")

async def foo(text):
    print(text)
    await (asyncio.sleep(3)) # эмулируем какую-то работу длительностью 3 сек
    
await main()
```
В примере выше, код отработал последовательно - то есть сначала, вывелось hello, затем world, а потом finished через 3 секунды. Но существует потребность выполнять их асинхронно, то есть выводить finished сразу же и не дожидаться пока доработает задача в корутине. 
Для этого есть специальный метод create_task()
```py
async def main():
    print("hello")
    task = asyncio.create_task(foo("world"))
    print("finished")

async def foo(text):
    print(text)
    await (asyncio.sleep(3)) # эмулируем какую-то работу длительностью 3 сек
    print("also finished")
await main()
```
Если вы внимательно присмотритесь к запуску, то увидите, что как ожидалось, последовательность изменилась: сначала вывелось слово hello, затем finished, потом world. Но ожидания в 3 секунды не было! то есть все три слова распечатались практически моментально. Однако работа в корутине продолжилась, для того, чтобы это подчеркнуть, я добавил вывод also finished после 3х секунд. 
> Вопрос: как нам опять засинхронизировать вывод не убирая asyncio.create_task?

Ниже чуть более сложный пример с ожиданиями, который стоит обсудить устно и проговорить логику работы ивент лупа в данной ситуации. 
```py
async def main():
    print("hello")  
    task = asyncio.create_task(foo("world"))
    print("finished")
    await (asyncio.sleep(4))
    print("finished 2")

async def foo(text):
    print(text)
    await (asyncio.sleep(3)) # эмулируем какую-то работу длительностью 3 сек
    print("also finished")
await main()
```
### Получение данных из корутины. 
Асинхронное программирование большая и сложная тема, и всю ее не охватить в этом уроке, однако один момет все же стоит еще обсудить. Это получение данных из корутины. Ранее в примерах выше мы в основном печатали данные в консоль. Однако чаще мы все таки отдаем какие-то данные из корутины. Для того, чтобы эти данные получить обязательно нужно их дождаться, то есть написать await. Рассмотрим пример ниже.
```py
async def fetch_data() -> dict:
    print("start fetching")  
    await asyncio.sleep(2)
    print("finished fetching")
    return {"data": 123}

async def print_numbers():
    for i in range(10):
        print(i)
        await asyncio.sleep(0.45)
        
async def main():
    fetching_task = asyncio.create_task(fetch_data())
    printing_task = asyncio.create_task(print_numbers())
    value = await fetching_task  # ожидаем тут значение из корутины
    print(value)

await main()
```
Из-за того, что в юпитере уже есть ивент луп мы используем await на мейне. Поэтому процессинг корутин не заканчивается, однако если запустить тот же код в пайчарме, то мы увидим, что цифры распечатались только до 7 - это произошло потому что мы не стали писать await printing_task. То есть дожидаться, пока вторая корутина доработает и завершили выполнение программы в целом. 
![image.png](https://i.imgur.com/sAHfgAR.png)

