---
aliases: [ООП, класс, инкапсуляция, полиморфизм, наследование, абстракция, SOLID]
---

## Основные понятия ООП
**Класс** – это способ описания сущности, определяющий состояние и поведение, зависящее от этого состояния, а также правила для взаимодействия с данной сущностью (контракт).  
  
С точки зрения программирования класс можно рассматривать как набор данных (полей, атрибутов, членов класса) и функций для работы с ними (методов).

**Объект (экземпляр)** – это отдельный представитель класса, имеющий конкретное состояние и поведение, полностью определяемое классом.  
  
Говоря простым языком, объект имеет конкретные значения атрибутов и методы, работающие с этими значениями на основе правил, заданных в классе. В данном примере, если класс – это некоторый абстрактный автомобиль из «мира идей», то объект – это конкретный автомобиль, стоящий у вас под окнами.
> В питоне все есть объект.

**Интерфейс** – это набор методов класса, доступных для использования другими классами.  
  
Очевидно, что интерфейсом класса будет являться набор всех его публичных методов в совокупности с набором публичных атрибутов. По сути, интерфейс специфицирует класс, чётко определяя все возможные действия над ним.

## Инкапсуляция, Абстракция,  Полиморфизм, Наследование
Сокрытие внутренних процессов, происходящих в автомобиле, позволяет эффективно его использовать даже тем, кто не является профессионалом-автомехаником с двадцатилетним стажем. Это сокрытие в ООП носит название инкапсуляции.

**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.

**Абстрагирование** – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, **абстракция** – это набор всех таких характеристик.

**Полиморфизм** – это свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта. Использовании единственной сущности(метод, оператор или объект) для представления различных типов в различных сценариях использования.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d02/7a3/0fa/d027a30faacfbb0f35e4f7e62656535c.png)

**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым или родительским. Новый класс – потомком, наследником или производным классом.
Необходимо отметить, что производный класс полностью удовлетворяет спецификации родительского, однако может иметь дополнительную функциональность. С точки зрения интерфейсов, каждый производный класс полностью реализует интерфейс родительского класса. Обратное не верно.

## SOLID принципы

![](https://habrastorage.org/r/w1560/webt/z5/b2/h8/z5b2h8gaf28pjknnrjz3tpjlfui.jpeg)

Принципы **SOLID** — это стандарт программирования, который широко используется в ООП.

-   **S: Single Responsibility Principle** (Принцип единственной ответственности).
-   **O: Open-Closed Principle** (Принцип открытости-закрытости).
-   **L: Liskov Substitution Principle** (Принцип подстановки Барбары Лисков).
-   **I: Interface Segregation Principle** (Принцип разделения интерфейса).
-   **D: Dependency Inversion Principle** (Принцип инверсии зависимостей).

**Принцип единственной ответственности**
> Один класс должен решать только какую-то одну задачу. 

Он может иметь несколько методов, но они должны использоваться лишь для решения общей задачи. Все методы и свойства должны служить одной цели. Если класс имеет несколько назначений, его нужно разделить на отдельные классы.

**Принцип открытости-закрытости**
> Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.

**Принцип подстановки Барбары Лисков**
> Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.

Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.
Методы, принимающие или возвращающие значения с типом некоего суперкласса  должны также принимать и возвращать значения, типами которых являются его подклассы.

**Принцип разделения интерфейса**
> Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.

Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.
Клиенты не должны реализовывать методы, которые им не нужно использовать. Кроме того, этот принцип указывает на то, что интерфейс должен решать лишь какую-то одну задачу (в этом он похож на принцип единственной ответственности), поэтому всё, что выходит за рамки этой задачи, должно быть вынесено в другой интерфейс или интерфейсы.

**Принцип инверсии зависимостей**
> Объектом зависимости должна быть абстракция, а не что-то конкретное.

1.  Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
2.  Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.

### MRO