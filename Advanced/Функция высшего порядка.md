---
aliases: [функция высшего порядка, high order function]
---

[[Декоратор]]
[[Декоратор с аргументами]]

Функции - как объект и функции высшего порядка, также немного о callable
Если ты помнишь самую первую лекцию Димана - то все в питоне является объектом. Листы, словари строки, множества итд. В том числе - функции.
```py
def add(x,y):
    return x+y
add
<function __main__.add(x, y)>
```
Интерпретатор сообщает нам, что add - это объект функции.
А раз это объект, то мы можем делать с этой функцией много интересных вещей. Например:

Вызвать ее:
```py
add(4,5)
9
```
Ну это я полагаю, ты знала и без меня.
А вот чего ты не знала:
() - это оператор вызова. Если мы хотим запустить какую-то функцию - то мы должны дописать обычные скобочки рядом с ней.
Не только функции могут быть вызваны. Еще и методы класса например. На самом деле любой объект, у которого есть метод _call_ может быть вызван.
() - всего лишь короткая запись над дандер метода.
```py
add.__call__(1,2)
3
lst = [1,2,3]
lst.pop.__call__()

3
lst = [1,2,3]
lst.pop()
3
```
Короче говоря - те объекты, у которых есть метод _call_ являются вызываемыми или callable.

Добавить еще одно название для нее:
Так как функции - это обычную объекты, а названия переменных - всего лишь хранят ссылки на участки памяти выделенные под объекты, мы легко можем создать новую ссылку на тот же участок памяти:
```py
add_new=add
add_new(2,3)
5
id(add)==id(add_new)
True
Дать название функции:
Как ты наверное помнишь, мы можем создать lambda функции, которые являются неименованными. Мы можем дать имя такой функции, чтобы переиспользовать ее.

(lambda x: x**2)(2)  #в таком виде мы никак не можем переиспользовать эту функцию. Сейчас она одноразовая.
4
sqr = lambda x: x**2 
print(sqr(4), sqr(2), sqr(1)) # а так можем!
16 4 1
```
Передать функцию, как аргумент в другую функцию:
Вопрос: можешь ли ты привести мне пример такого использования функции?

Ты уже не один раз сталкивалась с map filter и reduce в своей работе.
Это встроенные функции, которые принимают другие функции как аргумент
```py
lst = [2,3,4]
print(next(map(sqr, lst))) # обрати внимание, что тут нет вызова функции - тут мы только передаем ссылку на объект.
4
```
Задание: Написать свою вариацию функции map, которая возвращает генератор.
```py
from typing import Generator
def mymap(func, iterable: list)-> Generator:
```
Домашнее задание - написать filter аналогичным способом.

Мы можем объявить одну функцию внутри другой:
Когда мы используем Лямбду - мы объявляем ее внутри какой-то другой функции верно?
Так что нам запрещает объявить именованную функцию внутри другой функции? Ничего
```py
from random import choice
def say_hi():
    def choose_random_hi():
        return choice(['hello', 'привяу', 'добрый день, сударыня'])
    return choose_random_hi
```
функция выше - возвращает нам ссылку на другую функцию. В примеревыше - это не слишком полезно, но сама механика легко прослеживается
```py
say_hi()
<function __main__.say_hi.<locals>.choose_random_hi()>
```
Ее теперь можно записать в переменную и вызывать:
```py
greeting = say_hi()
greeting()
'привяу'
```
Или даже не записывать и это будет выглядеть странно)))
```py
say_hi()()
'привяу'
```
Вопрос: Конечно же мы можем возвращать не только объект самой функции, но и результат ее работы.Что для этого нужно поменять в коде?

Еще один пример использования тиакого подхода:
```py
def add_markdown(tag):
    
    def wrap_msg(msg):
        print(f'<{tag}>{msg}</{tag}>')
    return wrap_msg
add_code = add_markdown('code')
add_code('if __name__ == main')
add_paragraf = add_markdown('p')
add_paragraf('hello')
<code>if __name__ == main</code>
<p>hello</p>
if name == main

hello
```
Мы также можем хранить функции в стандартных типах данных.
Допустим мы хотим применить математические операции умножения, деления, сложения и вычитания к каким то двум парам чисел. Мы можем сделать например так:
```py
multiply = lambda x, y: x*y
divide = lambda x, y: x/y
_sum = lambda x, y: x+y
subtract = lambda x, y: x-y

operations = [multiply, divide, _sum, subtract]
for operation in operations:
    print(operation(2, 3))
6
0.6666666666666666
5
-1
```
А можем воспользоваться словарем:
```py
dict_operations = {
    '*' : multiply,
    '/' : divide,
    '+' : _sum,
    '-' : subtract
}
for key in dict_operations:
    print(dict_operations[key](2,3))
6
0.6666666666666666
5
-1
```
Задание: Напиши функцию calculator (operator, x, y) таким способом, чтобы:

все операции были в словаре
все операции были определены функциями внутри самой функции
возвращался результат вычислений
В следующей серии вы увидите:
Представим, что нам надо замерять время выполнения функции. Мы можем создать что-то универсальное, что будет принимать какую-то функцию как аргумент, засекать время до ее исполнения и засекать после и возвращать разницу.
```py
def timer(func):
    def wrapper(): # создаем функцию обертку
        from time import time # да так тоже можно
        begin = time() #засекаем время до
        func() # исполняем функцию
        end = time() # засекаем время после
        print(end-begin, 'nanoseconds') # печатаем сколько времени это заняло
    return wrapper # возвращаем объект функции
def say_hello():  # это наша функция, кроторую мы хотим замерять.
    print('Hello')

var = timer(say_hello)  # передаем объект функции в функцию таймер и записываем результат в переменную var
var() # запускаем wrapper

# say_hello()
Hello
0.0002148151397705078 nanoseconds
```
