---
aliases: [try, exept, конструкция с try]
---

Обработка исключений в Питоне.
В питоне, как ты уже знаешь есть встроенная конструкция, которая защищает твой код от падения. 
В каких-то случаях ты хочешь, чтобы твоя программа падала, а в каких-то нет. 
Прежде всего давай посмотримс на исключение
```py
x = 0
y = 4/x
y
--------------------------------------------
ZeroDivisionError                         Traceback (most recent call last)
<ipython-input-5-71c661153d9f> in <module>
           1 x = 0
---> 2 y = 4/x
           3 y

ZeroDivisionError: division by zero
```
Что с делала консоль? Она указала тебе тип ошибки: ZeroDivisionError. 
Указала интерпритатор, который использовался - ipython.
Указала в какой строке ошибка и - 2 и в конце дала расшифровку ошибки 

Но допустим в случае деления на ноль, мы хотим не прекращать выполнение программы, а скачем присваивать переменной какое-то иное значения.
Тут нам и поможет конструкция try except
```py
x = 0
try:
    y=5/x
except:
    y = 0
y
```
Все удалось и никакого сообщения выдано не было.
Но это не полный синтаксис данной конструкции. Полный синтаксис выглядит следующим образом.
```py
x = 0
try:
    y = 4/x
except:
    y = 0
else:
    print(y)
```
Обратила внимание, что данная конструкция ничего не вернула? Это потому то блок else выполняется только в случае успешного выполнения блока try.
Давай немного изменим код, чтобы это стало наглядно.
```py
x = 2
try:
    y = 4/x
except:
    y = 0
else:
    print(y)
```
В этот раз блок else выполнился. 

Теперь давай рассмотрим чуть с except чуть подробнее.
Во-первых, если не указать конкретное исключение, то except будет перехватывать все известные ему исключения.
А вот если указать какое-то, то только его (в примере ниже, в первом случае не будет ошибок, во втором будет)
```py
x = 0
try:
    y = 5/x
except ZeroDivisionError:
    y = 0

x = ''
try:
    y = 5/x
except ZeroDivisionError:
    y = 0
```
Какие типы исключений бывают? Есть базовые исключения и кастомные.
К базовым относятся исключения, которые не надо импортировать. С их списком ты можешь ознакомиться например вот здесь:
https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html

Хочу отметить, что блок except отлавливает не только конкретное исключение, если оно указано, но и всех его детей.
LookupError - некорректный индекс или ключ.
-----IndexError - индекс не входит в диапазон элементов.
-----KeyError - несуществующий ключ (в словаре, множестве или другом объекте).
```py
lst = [1,2,3]
try:
    print(lst[4])
except LookupError:
    print('нет такого индекса')
```
Также в блоке except можно указывать несколько исключений для отслеживания в форме кортежа. Также можно вставлять сколько угодно блоков except и обрабатывать исключения по отдельности
```py
x = 0
try:
    assert 5/x == 3
except (ZeroDivisionError, AssertionError):
    print('хрень понаписал')
```
Помнишь я говорил о полном синтаксисе? Тогда был не полный синтаксис. Потому что есть еще конструкция finally.
```py
try:
    f = open('index.html')
except:
    print('нет такого файла')
else:
    print('файл успешно открыт')
finally:
    f.close()
```
блок finally выполняется в любом случае, вне зависимости от того, было ли исключение или нет. Чаще всего его используют, когда надо сделать что-то обязательно,
например - закрыть файл или досьтуп к бд.

Теперь давай поговорим о том, как вызвать исключение. Для этого есть инструкция raise. 
```py
def foo(x:int)->int:
    print(x/10)
```
Функция выше ожидает на вход только int значение, так, что мы вполне можем добавить в нее вызов исключения.
```py
def foo(x:int)->int:
    if type(x) != int:
        raise TypeError
    else:
        print(x/10)

foo('')
```
такого же эффекта можно добиться утверждением, то есть assert type(x) == int,  но ошибка будет AssertionError

Из основ на этом все. Все что ниже - опционально.

Мы можем написать свое исключение.
```py
class MyError(Exception):
    def __init__(self, text, num):
        self.txt = text
        self.n = num

try:
    a = -1
    if a < 0:
        raise MyError('You gave negative: ', a)
except MyError as mr:
    print(mr)
else:
    print(a)
```
То есть мы просто наследовались от класса exception и прописали свой кастомный текст. Изично.
Возможно ты также обратила внимание, что мы сохранили ошибку в переменную mr, чтобы потом ее вывести в консоль. Так можно делать, чтобы логировать исключения, но не останавливать выполнение программы.

### Задача:

Написать функцию.
В функцию подаются три аргумента: файл, который надо открыть (имя строкой), элемент, который надо прочитать (int), мод, в котором надо открыть файл(строка) внутри файла будет предложение. Элемент - это слово в предложении.
Если файл открыт успешно, то программа должна выводить это слово в консоль.
Если не успешно, то должна выводить сообщение "Юль, нет такого файла, везде искала!"
Если файл открыт не в том моде, то должна выводить сообщение: "Юль, не могу прочитать - тут по эльфийски написано!"
Если прочитанное слово может быть int, то инициировать ошибку TypeError
В конце, естественно файл должен быть закрыт. Я проверю.

