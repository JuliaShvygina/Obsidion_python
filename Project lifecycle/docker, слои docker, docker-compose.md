---
aliases: [docker, layers, docer-compose, докер, слои докера]
---
```py

```

**Docker** — технология для создания и управления контейнерами.
![](https://i.imgur.com/DORPoV3.png)
Мы оборачиваем какой то код или приложение в контейнеры для того, чтобы он нам гарантировал одинаковое поведение в разных окружениях. Мы можем просто брать докер контейнеры и запускать их где угодно, где есть докер. Нам не важно, что это будет за ОС, его версия. Все поведение будет зафиксировано в контейнере.

**Docker** – это специальное программное обеспечение для той или иной операционной системы. Некий набор инструментов для разработчика, задействованный для автоматизации развертки и управления приложения. Основное предназначение Докера – **контейнеризация**.

Платформа и средства контейнерной виртуализации могут быть полезны в следующих случаях:  

-   упаковывание вашего приложения (и так же используемых компонент) в docker контейнеры;
-   раздача и доставка этих контейнеров вашим командам для разработки и тестирования;
-   выкладывания этих контейнеров на ваши продакшены, как в дата центры так и в облака.

### Для чего я могу использовать docker?

#### Быстрое выкладывание ваших приложений
Docker прекрасно подходит для организации цикла разработки. Docker позволяет разработчикам использовать локальные контейнеры с приложениями и сервисами. Что в последствии позволяет интегрироваться с процессом постоянной интеграции и выкладывания (continuous integration and deployment workflow).  
  
Например, ваши разработчики пишут код локально и делятся своим стеком разработки (набором docker образов) с коллегами. Когда они готовы, отравляют код и контейнеры на тестовую площадку и запускают любые необходимые тесты. С тестовой площадки они могут оправить код и образы на продакшен.  
  

#### Более простое выкладывание и разворачивание 
Основанная на контейнерах docker платформа позволят легко портировать вашу полезную нагрузку. Docker контейнеры могут работать на вашей локальной машине, как реальной так и на виртуальной машине в дата центре, так и в облаке.  
  
Портируемость и легковесная природа docker позволяет легко динамически управлять вашей нагрузкой. Вы можете использовать docker, чтобы развернуть или погасить ваше приложение или сервисы. Скорость docker позволяет делать это почти в режиме реального времени.  
  

#### Высокие нагрузки и больше полезных нагрузок 
Docker легковесен и быстр. Он предоставляет устойчивую, рентабельную альтернативу виртуальным машинам на основе гипервизора. Он особенно полезен в условиях высоких нагрузок, например, при создания собственного облака или платформа-как-сервис (platform-as-service). Но он так же полезен для маленьких и средних приложений, когда вам хочется получать больше из имеющихся ресурсов.

### Архитектура Docker
Docker использует архитектуру клиент-сервер. Docker клиент общается с демоном Docker, который берет на себя тяжесть создания, запуска, распределения ваших контейнеров. Оба, клиент и сервер могут работать на одной системе, вы можете подключить клиент к удаленному демону docker. Клиент и сервер общаются через сокет или через RESTful API.

#### Внутри docker-а  
Чтобы понимать, из чего состоит docker, вам нужно знать о трех компонентах:  

-   образы (images)
-   реестр (registries)
-   контейнеры
-   вольюмы
-   нетворк

#### Образы
Docker-образ — это read-only шаблон. Например, образ может содержать операционку Ubuntu c Apache и приложением на ней. Образы используются для создания контейнеров. Docker позволяет легко создавать новые образы, обновлять существующие, или вы можете скачать образы созданные другими людьми. Образы — это компонента сборки docker-а.  
  

#### Реестр
Docker-реестр хранит образы. Есть публичные и приватные реестры, из которых можно скачать либо загрузить образы. Публичный Docker-реестр — это [Docker Hub](http://hub.docker.com/). Там хранится огромная коллекция образов. Как вы знаете, образы могут быть созданы вами или вы можете использовать образы созданные другими. Реестры — это компонента распространения.  
  

#### Контейнеры
Контейнеры похожи на директории. В контейнерах содержится все, что нужно для работы приложения. Каждый контейнер создается из образа. Контейнеры могут быть созданы, запущены, остановлены, перенесены или удалены. Каждый контейнер изолирован и является безопасной платформой для приложения. Контейнеры — это компонента работы.

**Containers** — запускаются на основе образов

**Images** — шаблоны, только для чтения для создания контейнеров

![](https://i.imgur.com/ws2Ku4o.png)

На docker Hub лежат имаджи

#### Вольюмы
**Тома** — рекомендуемый разработчиками Docker способ хранения данных.
Для чего стоит использовать тома в Docker:
-   шаринг данных между несколькими запущенными контейнерами,
-   решение проблемы привязки к ОС хоста,
-   удалённое хранение данных,
-   бэкап или миграция данных на другой хост с Docker (для этого надо остановить все контейнеры и скопировать содержимое из каталога тома в нужное место).

#### Нетворк
**Сеть** Docker в основном используется для установления связи между контейнерами Docker и внешним миром через хост-машину, или вы можете сказать, что это коммуникационный канал, через который все изолированные контейнеры взаимодействуют друг с другом в различных ситуациях для выполнения необходимых действий.
![[Pasted image 20220209122519.png]]

## Docker vs Virtual Machine
![](https://i.imgur.com/UsxWikV.png)

1. Размер докер имаджа на много меньше, чем имадж виртуальной машины.
2. Скорость запуска докер контенера на много быстрее, чем виртуальной машины
3. Совместимость. Виртуальная машина любой ОС может запускаться на любой ОС хоста, в то время как докер такое может только через специальный docker toolbox.

## Базовые команды
`docker pull image_name` - получить образ из dockerhub
`docker images` - посмотреть все имаджи
`docker run [-d] [--name] image_name` - запустить контейнер (в detached режиме, с указанием имени)
`docker ps [-a]` - посмотреть (все) запущенные контейнеры
`docker stop container_id` - остановить контейнер
`docker start container_id` - запустить остановленный контейнер

### Порты
Иногда необходимо одновременно запустить два контейнера в одинаковыми образами разных версий. В таком случае, чтобы можно было с ними одновременно работать их необходимо подсоединить к разным портам на хосте.
![](https://i.imgur.com/LEPPZzi.png)

Для этого нужно явно указать порт для запуска контейнера, наприммер:
`docker run -p6000:6379 redis` и `docker run -p6001:6379 redis:4.0`
![](https://i.imgur.com/dAXk4tT.png)

## Дебаг докера
Случается, что что-то идет не так и приложение не подсоединяется к контейнеру. В таком случае нам хотелось бы видеть логи, что происходит в контейнере, чтобы понять, как решить проблему.

Чтобы увидеть логи контейнера можно использовать команду `docker logs container_id/conteainer_name`.

Дополнительно можно получить доступ к терминалу запущенного контейнера через команду `docker exec -it container_id /bin/bash`. Выйти из контейнера можно, набрав `exit`.

# Слои docker
Каждая команда в dockerfile создает свой слой в имадже. Чем больше слоев тем больше вес имаджа. Поэтому в dockerfile стараются объединять несколько команд в одну через &&.
Если вы захотите посмотреть на эти слои в первозданном виде, вы можете найти их в файловой системе на хост-машине. Они не видны напрямую из запущенного контейнера.

## Что такое Docker Compose?
Docker Compose — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.
Реальные проекты обычно включают в себя целый набор совместно работающих приложений. Если для обеспечения функционирования этого проекта используется несколько сервисов, то Docker Compose может вам пригодиться.
Технология Docker Compose, если описывать её упрощённо, позволяет, **с помощью одной команды, запускать множество сервисов**.

### Разница между Docker и Docker Compose
Docker применяется для управления отдельными контейнерами (сервисами), из которых состоит приложение.  
  
Docker Compose используется для одновременного управления несколькими контейнерами, входящими в состав приложения. Этот инструмент предлагает те же возможности, что и Docker, но позволяет работать с более сложными приложениями.
С помощью средства Compose можно создать файл YAML для определения служб и с помощью одной команды запускать и останавливать все, что нужно.

![](https://i.imgur.com/Av6ZpjT.png)

https://habr.com/ru/company/ruvds/blog/450312/ - хорошая статья с примером

### Создание файла Compose

1.  В корне проекта приложения создайте файл с именем `docker-compose.yml`.
2.  Написание файла Compose начнем с определения версии схемы. В большинстве случаев лучше использовать последнюю поддерживаемую версию. Текущие версии схемы и матрицу совместимости см. в [справочнике по файлу Compose](https://docs.docker.com/compose/compose-file/)
3.  Затем определим список служб (или контейнеров), которые требуется использовать как часть приложения.

```yaml
version: "3.7"

services:
```
4. Определите запись службы и наборы команд для контейнера. Для службы можно выбрать любое имя. Имя будет автоматически преобразовано в сетевой псевдоним, что будет полезно при определении службы MySQL.

https://docs.microsoft.com/ru-ru/visualstudio/docker/tutorials/use-docker-compose - хороший пример, чуть более сложный, чем пример выше.

![](https://i.imgur.com/5K1NCZ2.png)


## best practise
1. Используйте многоэтапные сборки
2. Располагайте команды в файлах Dockerfile в надлежащем порядке
3. Стремитесь к использованию как можно более компактных базовых образов Docker
4. Минимизируйте количество слоёв образов
5. Используйте непривилегированные контейнеры
6. Если это возможно — используйте COPY вместо ADD
7. Кешируйте Python-пакеты на Docker-хосте
8. Запускайте в одном контейнере лишь один процесс
9. Всегда, когда это возможно, используйте exec-формы инструкций CMD и ENTRYPOINT
10. Разберитесь с различиями инструкций ENTRYPOINT и CMD
11. Пользуйтесь инструкцией HEALTHCHECK
12. Ответственно подходите к версионированию Docker-образов
13. Не храните в образах секретные данные
14. Используйте файл .dockerignore
15. Производите линтинг файлов Dockerfile и сканирование образов
16. Подписывайте и верифицируйте образы
17. При необходимости используйте в контейнерах виртуальные окружения Python
18. Устанавливайте ограничения на использование процессора и памяти
19. Выполняйте логирование в stdout или stderr
20. При применении Gunicorn Heartbeat используйте директории, физически расположенные в памяти

[Практические рекомендации по работе с Docker для Python-разработчиков](https://habr.com/ru/company/wunderfund/blog/586778/)