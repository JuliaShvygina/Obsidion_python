---
aliases: [gitlab CI, CI]
---

Прочитать про [[CI-CD в разработке|CI/CD]] можно в отдельной статье. В рамках этой статьи будет освещено как настроить CI в GitLab.

Пайплайны для мастера и для веток обычно различаются. Ветки могут деплоиться на стейдж, но не могут на прод, мастер обычно наоборот.

### Регистрация раннера
Сперва требуется зарегистрировать раннер. Создаем проект, Settings -> CI/CD -> Runners.
Как это сделать описано в инструкции
![](https://i.imgur.com/EwMBJiz.png)

### Container Registry
Благодаря интегрированному в GitLab Container Registry каждый проект GitLab может иметь собственное пространство для хранения своих образов Docker.
Хранить образы можно, например, для того, чтобы иметь возможность деплоиться на любой из них, т.е. быстро откатывать изменения.
Обычно образы храняться тегированными, т.е. помеченными. Выбирать прометку следует с умом. Например, в проектах Адмитад ветки, что не будут деплоиться помечаются именем ветки и перезаписываются каждый раз при пуше этой ветки, а мастер ветка помечается тегом коммита и различна при каждом коммите в мастер.
Для тэгов принято использовать макросы. Все макросы можно определить по конструкции `${SOME_THING}`. Описанные выше макросы -  встроенные переменные GitLab. С полным списком можно ознакомиться в статье [Predefined variables reference](https://docs.gitlab.com/ee/ci/variables/predefined_variables.html). 

### Написание файла
Сама конфигурация хранится в файле .gitlab-ci.yml в корневом каталоге, это yml, который определяет:
* структуру и порядок джоб, которые должны быть запущены;
* решения, которые должен принимать раннер при возникновении определенных условий.

Базовый шаблон файла выглядит так:
```yml
default:
	variables:

	before_script:

	after_script:

stages:
	- build
	- test
	- deploy
	- push
	
build: # название джобы может быть любым
	stage: build
	script:
	
test:
	stage: test
	script:
	
deploy:
	stage: deploy
	script:

push:
	stage: push
	script:

```

В секцию `variables` выносятся константы, раздел заполняется после написания CI и содержит часто упоминаемые конструкции, строки. Вносить переменные можно и в другие этапы, тогда они будут перекрывать общие (дефолтные).  Например, в стадиях частро встречается конструкция
```yml
${CI_REGISTRY_IMAGE}/api_tests
```
вместо того, чтобы писать ее можно вынести ее в переменные:

```yml
variables:
	TEST_IMAGE: ${CI_REGISTRY_IMAGE}/api_tests
```
и писать лишь `${TEST_IMAGE}`.

Мы встретились с встроенным макросом `${CI_REGISTRY_IMAGE}`. 

Секция `before_script` выполняется перед выполнением стадий, в него обычно выносится авторизация в сторонних сервисах.
Зеркальный ему раздел `after_script` выполняется после всех стадий и может, например, выполнять очистку.
Оба раздела не являются обязательными и могут использоваться в любой из секций.

Секция `stages` является **обязательной** и содержит стадии пайплайна CI/CD (job'ы) в той последовательности, в которой они будут проходить сверху вниз. Если несколько job имеют одну стадию, то они запускаются параллельно. Следующие запускаются после успешно завершенных предыдущих.

В примере выше указана классическая схема, она может быть изменена.
Стандартно это:
- построение образа;
- прогон тестов;
- деплой;
- пуш образа в регистри.
Если секция не определена, то она считается равной
```yml
- [.pre](https://docs.gitlab.com/ee/ci/yaml/index.html#stage-pre)
- build
- test
- deploy
- [.post](https://docs.gitlab.com/ee/ci/yaml/index.html#stage-post)
```

Далее идут job'ы CI/CD в формате
```
название job`ы:
	stage: название стадии в рамках которой будет выполняться job`а
	script: выполняемый скрипт
```

#### Ключевые слова job'ы
Обязательные:
- `stage`
Используется для обозначения к какой стадии относится та или иная джоба.
- `script`
- Содержит непосредственно исполняемый код.

Дополнительные:
- `tags`
- `rules`
- `image`
- `services`
- `timeout`
- `trigger`
- `variables`
- `when`
- пр.

Все ключевые слова можно найти в [документации](https://docs.gitlab.com/ee/ci/yaml/index.html#stages). 


### Дополнительные возможности
Если необходимо использовать докер-контейнер при запуске job, необходимо прописать это в файле:
```yml
default: 
	image: ruby:2.7.4
```
Эта команда указывает исполнителю использовать образ Ruby из Docker Hub и запускать job'у в контейнере, сгенерированном из образа.
