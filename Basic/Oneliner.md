---
aliases: [oneliners, lambda, filter, map, reduce]
---
### Python Lambda Functions

**Ламбда функция** в питоне - это анонимная функция, которая может принимать неограниченное количество аргументов и обязана возвращать какое либо значение.

Шаблон следующий: labda arg1 arg1 ... argn: выражение

Простые выражения
##### Задание 1
Написать функцию, которая возводит подаваемое число в квадрат.
```py
def fun(x):
    return x**2
print(fun(4))
16
```
Теперь напишем тоже самое используя **lamda** выражение.
 Написать и запустить выражение ниже.
Ознакомиться с результатом и сделать предположения почему функция сработала именно так.
```py
lambda x: x**2
<function __main__.<lambda>(x)>
```
Дадим этой анонимной функции какое-то имя используя переменную.
```py
value = lambda x: x**2
```

Как же нам заставить функцию работать? Очень просто. Нам нужно передать в нее какой-либо аргумент.
```py
value(7)
```

##### Задание 2
Реализовать lambda функцию которая принимает 2 вещественных числа и возвращает целую часть от их произведения.
```py
value1 = lambda x, y: int(x*y)
value1(4.5,5.6)
25
```

### Сортировка
Часто нам нужно отсортировать какую-либо коллекцию не просто по возрастанию или убыванию, а как то более хитро.
Для этого используется специальный аргумент key=function(), где функция применяется к каждому элементу коллекции и к уже полученному результату применяется сортировка.
```py
def fun1(x):
    return x[1]
lis.sort(key = fun1)
lis
['Hello', 'Test', 'This', 'List', 'Is']
```
перепишем то же самое через lambda
```py
lis = ['Hello', 'This', 'Is', 'Test', 'List']
lis.sort(key=lambda x: x[1])
lis
['Hello', 'Test', 'This', 'List', 'Is']
```

Похожий сценарий может быть реализован и для словарей
Что в данном случае является 1 элементом?
```py
dic = [{'year': 1990, 'name': 'John'}, {'year': 1995, 'name': 'Emily'}, 
       {'year': 1992, 'name': 'Dan'}, {'year': 2018, 'name': 'Julie'}]
dic.sort(key = lambda x: x['year'])
dic
[{'year': 1990, 'name': 'John'},
 {'year': 1992, 'name': 'Dan'},
 {'year': 1995, 'name': 'Emily'},
 {'year': 2018, 'name': 'Julie'}]
```

##### Задание 3
Отсортировать этот же словарь по последней букве каждого значения по ключу name.
```py
dic.sort(key = lambda x: x['name'][-1])
dic
[{'year': 2018, 'name': 'Julie'},
 {'year': 1992, 'name': 'Dan'},
 {'year': 1990, 'name': 'John'},
 {'year': 1995, 'name': 'Emily'}]
 ```
Можно ли ничего не подавать в lambda функцию?
Можно! 
```py
fun2 = lambda:'hello'
fun2()
'hello'
```
А теперь вопрос: Почему здесь lambda без аргумента command = lambda: make_dis(entry1)
На самом деле мы присваиваем нашей лямбде имя command и когда происходит нажатие на кнопку, на самом деле это можно интерпретировать как вот такую запись command(),  то есть вызов метода.
Тут я жду от тебя вопроса про .bind() почему в .bind() методе мы передаем аргумент в lambda функцию? Именно потому что - это метод, а не аргумент. То есть метод должен применяться к чему-то, к какому то объекту, и поэтому он автоматически передает туда информацию ою объекте к которому применяется, то есть информацию о кнопке.
Для аргумента - это не нужно, так как он часть объекта и применяется в рамках него.

### Условные конструкты и циклы в lambda функциях
Циклы к сожалению не возможно реализовать в рамках lambda функций, чего нельзя сказать об условных конструкциях.
Напишите функцию, которая выводит отрицательное число или положительное.
```py
def checker(x):
    if x >= 0:
        print('positive')
    else:
        print('negative')
checker(7)
positive
```
Теперь реализуем то же самое только через лямбду.
шаблон будет следующим 
> lambda x: выражение если да if условие else выражение если нет
```py
checker2 = lambda x: print('positive') if x>=0 else print('negative')
checker2(-1)
negative
```
##### Задание 4 
Возвести все числа, которые делятся без остатка на два в квадрат
```py
x = [1,2,3,4,5,6,7,8,9,4]
i = 0
y = []
while i < len(x):
    fun = lambda x: x**2 if x%2==0 else x
    y.append(fun(x[i]))
    i+=1
y
    
[1, 4, 3, 16, 5, 36, 7, 64, 9, 16]
```

### Лямбда два. Возвращение Лямбды 
Э Джонни а можно ли возвращать другую функцию как результат работы первой? 
Этакая функция, которая генерит другие функции? Без б.
Вспомним как выглядит линейная функция
y = kx+b мы хотим такие фот функции генерить с различными аргументами, чтобы линии рисовать
```py
def linear(k, b):
    return lambda x: x*k+b
first_line = linear(2, 4)
first_line
<function __main__.linear.<locals>.<lambda>(x)>
first_line(3)
10
```
невероятно, да?

### MAP FILTER REDUCE
Ну а теперь посмотрим еще несколько очень крутых встроенных методов для работы с интерируемыми объектами.
Что на твой взгляд итерируемые объекты?

#### MAP
#### Задание 5 
Напишите функцию, которая ищет площади круга для заданного количества радиусов
```py
import math
rad = [1, 2, 3, 4, 5, 6, 7, 8]

def area(r):
    return math.pi*(r**2)

areas = []
for r in rad:
    areas.append(area(r))
areas
[3.141592653589793,
 12.566370614359172,
 28.274333882308138,
 50.26548245743669,
 78.53981633974483,
 113.09733552923255,
 153.93804002589985,
 201.06192982974676]
 ```
Не очень то удобно да?
Есть выход
```py
rad = [1, 2, 3, 4, 5, 6, 7, 8]
y = map(area, rad)
y
<map at 0x7f559af8bc18>
```
Не похоже как то на лист, да? но мы можем превратить это в лист используя явное преобразование.
```py
areas = list(map(area, rad))
areas
[3.141592653589793,
 12.566370614359172,
 28.274333882308138,
 50.26548245743669,
 78.53981633974483,
 113.09733552923255,
 153.93804002589985,
 201.06192982974676]
 ```
 
##### Задание номер 6 
Переписать задание номер 4 используя map.
```py
lst = [1,2,3,4,5,6,7,8,9,4]
y = list(map(lambda x: x**2 if x%2==0 else x, lst))
y
[1, 4, 3, 16, 5, 36, 7, 64, 9, 16]
```
можно использовать встроенные функции, такие как str, lst, sorted итд. Попробовать!
```py
lst = [1,2,3,4,5,6,7,8,9,4]
y = list(map(str, lst))
y
['1', '2', '3', '4', '5', '6', '7', '8', '9', '4']
z = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '4']
y = list(map(str.isdigit, z))
y
[True, True, True, True, True, True, True, True, True, True]
Filter
```

##### Задание номер 7. 
Написать функцию, которая создает новый лист со всеми значениями больше 10
```py
lst_new = [23, 1, 45, 34, 1, 2]
def func(lst):
    y = []
    for i in lst:
        if i > 10:
            y.append(i)
    return y
func(lst_new)
[23, 45, 34]
```
В питоне есть встроенная функция filter которая позволяет создать новый список из уже существующего по критерию заданному функцией. Заданная функция должна возвращать True или False
```py
x = [1, 4, 43 ,3]
def f(i):
    return i > 3
y = list(filter(f, x))
y
[4, 43]
```
 а что если нам надо отфильтровать из листа все ненулевые элементы?
 ```py
lst = [0,1,0,1,1,1,0,0]
lst1=list(filter(None, lst))
lst1
```
данном случае все none значения Не включаются в новый список. None может быть и пустой строкой.
[1, 1, 1, 1]
ПЕрепишем задание номер 6 через лямбду
```py
lst_new = [23, 1, 45, 34, 1, 2]
y = list(filter(lambda x: x if x>10 else 0, lst_new))
y
[23, 45, 34]
```
также как map, filter понимает встроенные функции и скажем может принимать bool или str, чтобы вернуть только существующие значения или только строки. Более того она может использовать и встроенные в эти объекты методы
Например str.isdigit()
```py
a = '432abc'
b = list(filter(str.isdigit, a))
b
['4', '3', '2']
```
Рассмотрим как фильтровать словари. Помним, что в питоне обход словаря происходит по ключу.
dic = {
    'moscow': 800,
    'boston' : 750,
    'LA': 400,
    'SF':900,
    'Chokago': 65