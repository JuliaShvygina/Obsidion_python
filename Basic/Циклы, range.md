---
aliases: [цикл, циклы, циклом, for, while, range]
---


Каждый язык программирования, с которым я сталкивался, содержит какую-нибудь **конструкцию цикла**. В большей части языков есть больше одной такой конструкции. В мире Python есть два типа циклов:

-   Цикл **for**
-   Цикл **while**

### While

Цикл `while` (“пока”) позволяет выполнить одну и ту же последовательность действий, пока проверяемое условие истинно. Условие записывается до тела цикла и проверяется до выполнения тела цикла. Как правило, цикл `while` используется, когда невозможно определить точное значение количества проходов исполнения цикла.
`While` - это более простой цикл. Он не позволит итерироваться по последовательностям напрямую. Ему обязательно нужно условие и счетчик

```py
i = 0
while i < 10:
    print(i)
    i = i + 1
```
Если вы запустите этот код, он выдаст от 0 до 9, каждая цифра будет в отдельной строке, после чего задача будет выполнена. Если вы удалите ту часть, в которой мы увеличиваем значение i, то мы получим **бесконечный цикл**. Как правило – это плохо. **Бесконечные циклы** известны как логические ошибки, и их нужно избегать. Существует другой способ вырваться из цикла, для этого нужно использовать встроенную функцию **break**.

```py
while i < 10:
    print(i)
    
    if i == 5:
        break
    
    i += 1
```
В этой части кода мы добавили условное выражение для проверки того, равняется ли когда-либо переменная i цифре 5. Если нет, тогда мы **разрываем цикл**. Как вы видите в выдаче кода, как только значение достигает пяти, код останавливается, даже если мы ранее указали **while** продолжать цикл, пока переменная не достигнет значения 10.
Встроенный **break** также известен как инструмент управления потока.

Существует еще один, под названием **continue**, который в основном используется для пропуска итерации, или перейти к следующей итерации.

```py
i = 0
 
while i < 10:
    if i == 3:
        i += 1
        continue
    
    print(i)
    if i == 5:
        break
    
    i += 1
```
Мы добавили второе условное выражение, которое проверяет, не равняется ли i трем. Если да, мы увеличиваем переменную и переходим к **следующему циклу**, который удачно пропускает вывод значения 3 на экран. Как и ранее, когда мы достигаем значения 5, мы **разрываем цикл**. Существует еще одна тема, касающаяся циклов, которую нам нужно затронуть – это **оператор else**.

**Оператор else** в циклах выполняется только в том случае, если цикл выполнен успешно. Главная задача **оператора else**, это поиск объектов:
```py
my_list = [1, 2, 3, 4, 5]
 
for i in my_list:
    if i == 3:
        print("Item found!")
        break
    print(i)
else:
    print("Item not found!")
```
В этом коде мы **разорвали цикл**, когда i равно 3. Это приводит к пропуску **оператора else**.

### For
Цикл **for** работает очень занимательно. У него есть все те же операторы что и в `while`, то есть `break`, `continue`, `else`. Но ему не нужен **счетчик**. Зато ему очень нужна **итерируемая последовательность**.

Чтобы задать последовательность часто можно пользоваться функцией **range**.
- range(**старт**,[ **стоп**[, **шаг**]]) включает элемент старт, но не включает элемент стоп.

```py
a = range(5, 10)
print(a) # range(5, 10)
 
b = list(range(1, 10, 2))
print(b) # [1, 3, 5, 7, 9]
```

**Цикл for** может обходить любой итератор Python. Когда вы используете **for в словаре**, вы увидите, что он автоматически **перебирает ключи**. Вам не нужно указывать ключ for в **a\_dict.keys()** (впрочем, это также работает).

Eсли у нас двойная итерируемая последовательность, то можно итерироваться по 2м элементам сразу/
```py
dic = {'key':'value', 'key1':'value'}
for key, value in dic.items(): print(key, '-->', value)
# key --> value
# key1 --> value
```

Когда мы используем цикл for он вытаскивает из объекта метод **__iter__**, который являет собой поток данных. одноразовый. Затем он применяет к нему функцию **next()** и это есть одна итерация. Из потока данных при этом убирается вызванный элемент и в следующий раз next возвратит уже следующий, до тех пор пока не будет ошибки `stopiteration`.
```py
iterator_lst = iter(lst)
next(iterator_lst)
```

Реализуем цикл for через while:
```py
lst1 = [1,2,3,4,5]
lst1_iter = iter(lst1)
while True:
    try:
        word = next(lst1_iter)
        print(word)
    except StopIteration:
        break
```