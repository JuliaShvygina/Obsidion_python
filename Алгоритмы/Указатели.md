---
aliases:
  - two pointers
  - указатели
  - pointers
---
![[Pasted image 20250218113945.png]]

Если вы когда-либо работали с языками более низкого уровня, такими как C или C++, то, вероятно, слышаи об указателях. Указатели позволяют повысить эффективность некоторых частей вашего кода. Они также вызывают путаницу у новичков и могут привести к различным ошибкам в управлении памятью, даже у экспертов. Итак, где они находятся в Python и как вы можете имитировать указатели в Python?

Указатели широко используются в C и C++. По сути, они представляют собой переменные, которые содержат адрес в памяти другой переменной. Для получения дополнительной информации об указателях вы можете ознакомиться с этим обзором указателей на C.

В этой статье вы получите лучшее представление об объектной модели Python и узнаете, почему указателей в Python на самом деле не существует. В тех случаях, когда вам нужно имитировать поведение указателей, вы узнаете, как имитировать указатели в Python без кошмарных проблем с управлением памятью.

### Почему в Python нет указателей?

По правде говоря, я не знаю. Могут ли указатели в Python существовать изначально? Возможно, но указатели, похоже, противоречат принципам Python. Указатели поощряют неявные изменения. Часто они оказываются усложнение, а не упрощением, особенно для начинающих. Что еще хуже, они предлагают способы прострелить себе ногу или сделать что-то действительно опасное, например, прочитать отрывок из памяти, который вы не должны были читать.

Python, как правило, пытается абстрагироваться от деталей реализации, таких как адреса памяти, от своих пользователей. Python часто фокусируется на удобстве использования, а не на скорости. В результате указатели в Python на самом деле не имеют смысла. Не бойтесь, Python по умолчанию предоставляет вам некоторые преимущества использования указателей.

Понимание указателей в Python требует краткого ознакомления с деталями реализации Python. В частности, вам нужно будет понять:

1. Неизменяемые и изменяемые объекты
2. Переменные/имена Python
Запомните свои адреса, и давайте начнем.

### Объекты в Python
В Python все является объектом. Для доказательства вы можете открыть REPL и изучить его с помощью` isinstance()`:
```python
>>> isinstance(1, object)
True
>>> isinstance(list(), object)
True
>>> isinstance(True, object)
True
>>> def foo():
...     pass
...
>>> isinstance(foo, object)
True
```

Этот код показывает вам, что все в Python действительно является объектом. Каждый объект содержит как минимум три элемента данных:

1. Количество ссылок
2. Тип
3. Значение

**Счетчик ссылок** предназначен для управления памятью. Для более подробного ознакомления с внутренними компонентами управления памятью в Python вы можете прочитать [[TODO Управление памятью в Python]].

**Тип** используется на уровне CPython для обеспечения безопасности типов во время выполнения. Наконец, есть **значение**, которое является фактическим значением, связанным с объектом.

Однако не все объекты одинаковы. Есть еще одно важное различие, которое вам нужно понять: [[TO UPDATE изменяемые и неизменяемые объекты]]. Понимание разницы между типами объектов действительно помогает прояснить первый слой "луковицы", который представляет собой указатели в Python.

### Понимание переменных
Переменные Python принципиально отличаются от переменных в C или C++. На самом деле, в Python даже нет переменных. *В Python есть имена, а не переменные*.

Это может показаться педантичным, и по большей части так оно и есть. В большинстве случаев вполне допустимо рассматривать имена Python как переменные, но важно понимать разницу. Это особенно актуально, когда вы разбираетесь в сложной теме указателей в Python.

Чтобы лучше понять разницу, вы можете взглянуть на то, как работают переменные в C, что они представляют, а затем сравнить это с тем, как работают имена в Python.

#### Переменные в C
Допустим, у вас есть следующий код, который определяет переменную x:
```
int x = 2337;
```
Выполнение этой строки кода состоит из нескольких отдельных шагов:

1. Выделите достаточно памяти для целого числа
2. Присвойте этой ячейке памяти значение 2337
3. Укажите, что x указывает на это значение
В упрощенном представлении памяти это может выглядеть следующим образом:
![[Pasted image 20250218114023.png]]

Здесь вы можете видеть, что переменная x имеет поддельную ячейку памяти 0x7f1 и значение 2337. Если позже в программе вы захотите изменить значение x, вы можете сделать следующее:
```
x = 2338;
```
Приведенный выше код присваивает новое значение (2338) переменной x, тем самым перезаписывая предыдущее значение. Это означает, что переменная x может изменяться. Обновленная структура памяти отображает новое значение:
![[Pasted image 20250218114032.png]]
Новое представление X (2338) в памяти.

Обратите внимание, что местоположение x не изменилось, изменилось только само значение. Это важный момент. Это означает, что x - это ячейка памяти, а не просто ее название.

Еще один способ осмыслить эту концепцию - с точки зрения владения. В некотором смысле, x владеет ячейкой памяти. x - это, во-первых, пустая ячейка, в которую может поместиться ровно одно целое число, в котором могут храниться целые значения.

Когда вы присваиваете значение x, вы помещаете значение в поле, которому принадлежит x. Если вы хотите ввести новую переменную (y), вы можете добавить эту строку кода:
```
int y = x;
```
Этот код создает новый блок с именем y и копирует в него значение из x. Теперь схема расположения в памяти будет выглядеть следующим образом:
![[Pasted image 20250218114042.png]]
Представление X (2338) и Y (2338) в памяти.

Обратите внимание на новое местоположение y - 0x7f5. Несмотря на то, что значение x было скопировано в y, переменной y принадлежит некоторый новый адрес в памяти. Таким образом, вы можете перезаписать значение y, не затрагивая x:
```
y = 2339;
```
Теперь структура памяти будет выглядеть следующим образом:
![[Pasted image 20250218114050.png]]
Обновлено представление Y (2339).

Опять же, вы изменили значение в y, но не его местоположение. Кроме того, вы вообще не затронули исходную переменную x. Это резко контрастирует с тем, как работают имена в Python.

#### Имена в Python
В Python нет переменных. У него есть имена. Да, это педантичный момент, и вы, конечно, можете использовать термин "переменные" сколько угодно. Важно знать, что между переменными и именами есть разница.

Давайте возьмем эквивалентный код из приведенного выше примера C и запишем его на Python:
```python
>>> x = 2337
```
Как и в C, приведенный выше код разбивается на несколько отдельных шагов во время выполнения:

- Создайте PyObject
- Задайте для PyObject значение typecode равным integer
- Задайте значение 2337 для PyObject
- Создайте имя с именем x
- Укажите x на новый PyObject
- Увеличьте значение refcount для PyObject на 1

> Примечание: PyObject - это не то же самое, что объект Python. Он специфичен для CPython и представляет базовую структуру для всех объектов Python.
> PyObject определен как структура C, поэтому, если вам интересно, почему вы не можете напрямую вызвать typecode или refcount, это потому, что у вас нет прямого доступа к структурам. Вызовы методов, таких как `sys.getrefcount()`, могут помочь получить некоторые внутренние данные.

В памяти это может выглядеть примерно так:
![[Pasted image 20250218114101.png]]
Представление X (2337) в Python в памяти
Вы можете видеть, что структура памяти значительно отличается от предыдущей структуры C. Вместо того, чтобы x владел блоком памяти, в котором находится значение 2337, недавно созданный объект Python владеет памятью, в которой находится 2337. Имя x в Python не имеет прямого отношения к какому-либо адресу памяти, в отличие от того, как переменной x в C принадлежит статический слот в памяти.

Если бы вы попытались присвоить x новое значение, вы могли бы попробовать следующее:
```python
 x = 2338
```
То, что здесь происходит, отличается от эквивалента на C, но не слишком отличается от исходного `bind` в Python.

Этот код:
- Создает новый PyObject
- Присваивает коду типа `integer` значение для PyObject
- Присваивает значение `2338` для PyObject
- Указывает `x` на новый PyObject
- Увеличивает количество повторных ссылок для нового PyObject на 1
- Уменьшает повторное использование старого PyObject на 1

Теперь в памяти это будет выглядеть примерно так:
![[Pasted image 20250218114112.png]]
Имя Python, указывающее на новый объект (2338)
Эта диаграмма помогает проиллюстрировать, что x указывает на ссылку на объект и не владеет пространством памяти, как раньше. Это также показывает, что команда x = 2338 - это не присвоение, а скорее привязка имени x к ссылке.

Кроме того, предыдущий объект (который содержал значение 2337) теперь находится в памяти с количеством ссылок, равным 0, и будет очищен [[Сборщик мусора (Garbage Collector)|сборщиком мусора]].

Вы могли бы ввести новое имя, y, для объединения, как в примере с C:
```
y = x
```
В памяти у вас будет новое имя, но не обязательно новый объект:
![[Pasted image 20250218114121.png]]
Имена X и Y указывают на 2338.
Теперь вы можете видеть, что новый объект Python не был создан, просто новое имя, указывающее на тот же объект. Кроме того, количество повторных обращений к объекту увеличилось на единицу. Вы можете проверить идентичность объектов, чтобы убедиться, что они совпадают:
```python
>>> y is x
True
```

Приведенный выше код указывает на то, что x и y - это один и тот же объект. Однако не заблуждайтесь: y по-прежнему остается неизменяемым.

Например, вы могли бы выполнить сложение с y:

```python
>>> y += 1
>>> y is x
False
```
После вызова `addition` вы возвращаетесь с новым объектом Python. Теперь память выглядит следующим образом:
![[Pasted image 20250218114131.png]]
x и y называют разные объекты.
Создан новый объект, и y теперь указывает на новый объект. Интересно, что это то же самое конечное состояние, если бы вы напрямую привязали y к 2339:

```python
>>> y = 2339
```
Приведенный выше оператор приводит к тому же состоянию конечной памяти, что и добавление. Напомним, что в Python вы не присваиваете переменные. Вместо этого вы привязываете имена к ссылкам.

#### Небольшое замечание о встроенных объектах в Python
Теперь, когда вы понимаете, как создаются объекты Python и как к этим объектам привязываются имена, пришло время внести ясность в механизм. Этот механизм называется "встроенные объекты".

Предположим, у вас есть следующий код на Python:
```python
>>> x = 1000
>>> y = x
>>> x is y
True
```
Как указано выше, x и y - это имена, которые указывают на один и тот же объект Python. Но не всегда гарантируется, что объект Python, содержащий значение 1000, будет иметь один и тот же адрес памяти. Например, если бы вы также присвоили y литерал 1000, то в итоге получили бы другой адрес памяти:
```python
>>> x = 1000
>>> y = 1000
>>> x is y
False
```
На этот раз строка x - y возвращает значение `False`. Если это сбивает с толку, то не волнуйтесь. Вот шаги, которые выполняются при выполнении этого кода:

1. Создайте объект Python (1000)
2. Присвойте этому объекту имя x
3. Создайте новый объект Python (1000)
4. Присвойте этому объекту имя y

>Примечание: Описанные выше шаги выполняются только тогда, когда этот код выполняется внутри REPL. Если бы вы взяли приведенный выше пример, вставили его в файл и запустили файл, то вы бы обнаружили, что строка x is y возвращает значение True.
>Это происходит потому, что компиляторы умны. Компилятор CPython пытается выполнить оптимизацию, называемую оптимизацией на глазок, которая помогает по возможности экономить этапы выполнения.

Разве это не расточительно? Да, это так, но это цена, которую вы платите за все замечательные преимущества Python. Вам никогда не придется беспокоиться об очистке этих промежуточных объектов или даже знать, что они существуют! Радует то, что эти операции выполняются относительно быстро, и до сих пор вам не приходилось знать ни одной из этих деталей.

Разработчики ядра Python, в меру своей мудрости, также заметили это расточительство и решили провести несколько оптимизаций. В результате этих оптимизаций поведение, которое может удивить новичков:
```python
>>> x = 20
>>> y = 20
>>> x is y
True
```
В этом примере вы видите почти тот же код, что и раньше, за исключением того, что на этот раз результат равен `True`. Это результат использования встроенных объектов. Python предварительно создает определенное подмножество объектов в памяти и сохраняет их в глобальном пространстве имен для повседневного использования.

Какие объекты зависят от реализации Python. В CPython 3.7 используются следующие значения:

- Целые числа от -5 до 256
- Строки, содержащие только буквы ASCII (от A до Z и от а до я), цифры и символы подчеркивания

Причина этого в том, что эти объекты, скорее всего, будут использоваться во многих программах. Например, большинство имен переменных в Python указаны во втором маркере. Путем интернирования этих объектов Python предотвращает вызовы выделения памяти для последовательно используемых объектов.

Строки длиной менее 20 символов, содержащие буквы ASCII, цифры или символы подчеркивания, будут интернированы. Это может повысить эффективность использования этих строк при сравнении:
```python
>>> s1 = "realpython"
>>> id(s1)
140696485006960

>>> s2 = "realpython"
>>> id(s2)
140696485006960

>>> s1 is s2
True
```
Здесь вы можете видеть, что `s1` и `s2` указывают на один и тот же адрес в памяти. Если бы вы ввели символ, который не является буквой ASCII, цифрой или символом подчеркивания, то получили бы другой результат:
```python
>>> s1 = "Настоящий Python!"
>>> s2 = "Настоящий Python!"
>>> s1 is s2
False
```
Поскольку в этом примере есть восклицательный знак (!), эти строки не интернированы и являются разными объектами в памяти.

> Бонус: Если вы действительно хотите, чтобы эти объекты ссылались на один и тот же внутренний объект, то вы можете проверить `sys.intern()`. Один из вариантов использования этой функции описан в документации:
>>Интернирование строк полезно для повышения производительности поиска по словарю — если ключи в словаре интернированы, а ключ поиска интернирован, сравнение ключей (после хэширования) может выполняться с помощью сравнения указателя вместо сравнения строк. ([Источник](https://docs.python.org/3/library/sys.html#sys.intern))

Встроенные объекты часто являются источником путаницы. Просто помните, если у вас когда-нибудь возникнут сомнения, что вы всегда можете использовать` id()` и `is` для определения равенства объектов.

### Моделирование указателей в Python
То, что указатели в Python не существуют изначально, не означает, что вы не можете воспользоваться преимуществами использования указателей. На самом деле, существует несколько способов моделирования указателей в Python. В этом разделе вы узнаете о двух из них:

1. Использование изменяемых типов в качестве указателей
2. Использование пользовательских объектов Python
Хорошо, давайте перейдем к сути.

#### Использование изменяемых типов в качестве указателей
Вы уже узнали о изменяемых типах. Поскольку эти объекты изменяемы, вы можете обращаться с ними так, как если бы они были указателями, чтобы имитировать поведение указателя. Предположим, вы хотите воспроизвести следующий код на c:

```c
void add_one(int *x) {
    *x += 1;
}
```
Этот код принимает указатель на целое число (`*x`) и затем увеличивает значение на единицу. Вот основная функция для выполнения кода:
```c
#include <stdio.h>

int main(void) {
    int y = 2337;
    printf("y = %d\n", y);
    add_one(&y);
    printf("y = %d\n", y);
    return 0;
}
```
В приведенном выше коде вы присваиваете y значение 2337, выводите текущее значение, увеличиваете значение на единицу и затем выводите измененное значение. Результат выполнения этого кода будет следующим:
```shell
y = 2337
y = 2338
```

Один из способов воспроизвести этот тип поведения в Python - использовать изменяемый тип. Рассмотрите возможность использования списка и изменения первого элемента:
```python
>>> def add_one(x):
...     x[0] += 1
...
>>> y = [2337]
>>> add_one(y)
>>> y[0]
2338
```
Здесь `add_one(x)` обращается к первому элементу и увеличивает его значение на единицу. Использование списка означает, что конечный результат, по-видимому, изменил значение. Значит, указатели в Python действительно существуют? Ну, нет. Это возможно только потому, что `list` является изменяемым типом. Если вы попытаетесь использовать кортеж, вы получите сообщение об ошибке:
```python
>>> z = (2337,)
>>> add_one(z)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 2, in add_one
TypeError: 'tuple' object does not support item assignment
```
Приведенный выше код демонстрирует, что `tuple` является неизменяемым. Следовательно, он не поддерживает назначение элементов. `list` - не единственный изменяемый тип. Другим распространенным подходом к имитации указателей в Python является использование `dict`.

Допустим, у вас есть приложение, в котором вы хотите отслеживать каждый раз, когда происходит интересное событие. Одним из способов добиться этого было бы создать `dict` и использовать один из элементов в качестве счетчика:
```python
>>> counters = {"func_calls": 0}
>>> def bar():
...     counters["func_calls"] += 1
...
>>> def foo():
...     counters["func_calls"] += 1
...     bar()
...
>>> foo()
>>> counters["func_calls"]
2
```
В этом примере словарь счетчиков используется для отслеживания количества вызовов функций. После вызова функции `foo()` счетчик, как и ожидалось, увеличился до 2. Все потому, что `dict` является изменяемым.

Имейте в виду, что это только имитирует поведение указателя и напрямую не сопоставляется с истинными указателями в C или C++. Иными словами, эти операции обходятся дороже, чем в C или C++.

#### Использование объектов Python
Опция `dict` - отличный способ эмулировать указатели в Python, но иногда запоминать имя используемого ключа становится утомительно. Это особенно актуально, если вы используете словарь в различных частях своего приложения. Вот где действительно может помочь пользовательский класс Python.

Основываясь на последнем примере, предположим, что вы хотите отслеживать показатели в своем приложении. Создание класса - отличный способ абстрагироваться от неприятных деталей:
```python
class Metrics(object):
    def __init__(self):
        self._metrics = {
            "func_calls": 0,
            "cat_pictures_served": 0,
        }
```

Этот код определяет класс `Metrics`. Этот класс по-прежнему использует `dict` для хранения фактических данных, которые находятся в переменной `_metrics`. Это обеспечит необходимую изменчивость. Теперь вам просто нужно иметь доступ к этим значениям. Один из хороших способов сделать это - использовать свойства:
```python
class Metrics(object):
    # ...

    @property
    def func_calls(self):
        return self._metrics["func_calls"]

    @property
    def cat_pictures_served(self):
        return self._metrics["cat_pictures_served"]
```
В этом коде используется `@property`. Если вы не знакомы с [[Декоратор|декораторами]], вы можете ознакомиться с этим руководством по декораторам Python. Приведенный здесь` @property decorator` позволяет вам обращаться к `func_calls` и `cat_pictures_served`, как если бы они были атрибутами:
```python
>>> metrics = Metrics()
>>> metrics.func_calls
0
>>> metrics.cat_pictures_served
0
```
Тот факт, что вы можете обращаться к этим именам как к атрибутам, означает, что вы абстрагировали тот факт, что эти значения содержатся в `dict`. Вы также более четко указываете, каковы имена атрибутов. Конечно, вам нужно иметь возможность увеличивать эти значения:
```python
class Metrics(object):
    # ...

    def inc_func_calls(self):
        self._metrics["func_calls"] += 1

    def inc_cat_pics(self):
        self._metrics["cat_pictures_served"] += 1
```
Вы ввели два новых метода:
1. `inc_func_calls()`
2. `inc_cat_pics()`

Эти методы изменяют значения в dict'е метрик. Теперь у вас есть класс, который вы изменяете, как если бы вы изменяли указатель:
```python
>>> metrics = Metrics()
>>> metrics.inc_func_calls()
>>> metrics.inc_func_calls()
>>> metrics.func_calls
2
```
Здесь вы можете получить доступ к `func_calls` и вызвать `inc_func_calls()` в различных местах ваших приложений и имитировать указатели на Python. Это полезно, когда у вас есть что-то вроде метрик, которые необходимо часто использовать и обновлять в различных частях ваших приложений.

> Примечание: В частности, в этом классе явное использование `inc_func_calls(`) и `inc_cat_pics()` вместо использования `@property.setter` не позволяет пользователям устанавливать для этих значений произвольное значение int или недопустимое значение типа `dict`.

Вот полный исходный код для класса Metrics:
```python
class Metrics(object):
    def __init__(self):
        self._metrics = {
            "func_calls": 0,
            "cat_pictures_served": 0,
        }

    @property
    def func_calls(self):
        return self._metrics["func_calls"]

    @property
    def cat_pictures_served(self):
        return self._metrics["cat_pictures_served"]

    def inc_func_calls(self):
        self._metrics["func_calls"] += 1

    def inc_cat_pics(self):
        self._metrics["cat_pictures_served"] += 1
```

### Настоящие указатели с ctypes
Хорошо, возможно, в Python есть указатели, в частности, в CPython. Используя встроенный модуль `ctypes`, вы можете создавать настоящие указатели в стиле C в Python. Если вы не знакомы с `ctypes`, то можете взглянуть на расширение Python с помощью библиотек C и модуля “`ctypes`”.

Реальная причина, по которой вы бы использовали это, заключается в том, что вам нужно вызвать функцию библиотеки C, для которой требуется указатель. Давайте вернемся к предыдущей C-функции `add_one()`:
```c
void add_one(int *x) {
    *x += 1;
}
```
И здесь этот код увеличивает значение x на единицу. Чтобы использовать это, сначала скомпилируйте его в общий объект. Предполагая, что указанный выше файл хранится в `add.c`, вы могли бы выполнить это с помощью `gcc`:
```shell
$ gcc -c -Wall -Werror -fpic add.c
$ gcc -shared -o libadd1.so add.o
```
Первая команда компилирует исходный файл C в объект с именем `add.o`. Вторая команда использует этот несвязанный объектный файл и создает общий объект с именем` libadd1.so`.

`libadd1.so` должен находиться в вашем текущем каталоге. Вы можете загрузить его в Python, используя ctypes:
```python
>>> import ctypes
>>> add_lib = ctypes.CDLL("./libadd1.so")
>>> add_lib.add_one
<_FuncPtr object at 0x7f9f3b8852a0>
```
Код ctypes.CDLL возвращает объект, который представляет общий объект `libadd1`. Поскольку вы определили `add_one()` в этом общем объекте, вы можете обращаться к нему, как к любому другому объекту Python. Однако перед вызовом функции вам следует указать сигнатуру функции. Это помогает Python гарантировать, что вы передадите функции правильный тип.

В этом случае сигнатура функции представляет собой указатель на целое число. ctypes позволит вам указать это, используя следующий код:
```python
>>> add_one = add_lib.add_one
>>> add_one.argtypes = [ctypes.POINTER(ctypes.c_int)]
```
В этом коде вы устанавливаете сигнатуру функции в соответствии с ожиданиями C. Теперь, если вы попытаетесь вызвать этот код с неправильным типом, то вместо неопределенного поведения получите приятное предупреждение:
```python
>>> add_one(1)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ctypes.ArgumentError: argument 1: <class 'TypeError'>: \
expected LP_c_int instance instead of int
```
Python выдает ошибку, объясняющую, что `add_one()` хочет получить указатель, а не просто целое число. К счастью, в ctypes есть способ передавать указатели на эти функции. Сначала объявите целое число в стиле C:
```python
>>> x = ctypes.c_int()
>>> x
c_int(0)
```
Приведенный выше код создает целое число x в стиле C со значением 0. `ctypes` предоставляет удобную функцию `byref()`, позволяющую передавать переменную по ссылке.

>Примечание: Термин "По ссылке" противоположен передаче переменной по значению.
>При передаче по ссылке вы передаете ссылку на исходную переменную, и, таким образом, изменения будут отражены в исходной переменной. Передача по значению приводит к созданию копии исходной переменной, а изменения не отражаются в оригинале.
>Для получения дополнительной информации о передаче по ссылке в Python ознакомьтесь с разделом "Передача по ссылке в Python: общие сведения и рекомендации".

Вы можете использовать это для вызова функции `add_one()`:
```python
>>> add_one(ctypes.byref(x))
998793640
>>> x
c_int(1)
```
Мило! Ваше целое число увеличилось на единицу. Поздравляем, вы успешно использовали реальные указатели в Python.

### Решение задач
#### [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)

```
You are given an array prices where prices[i] is the price of a given stock on the ith day.
You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.
Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

Example 1:
Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

Example 2:
Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.
```

Решение: жадный алгоритм + два указателя.
```python
# самый лучший вариант это взять минимум слева и максимум справа от него.
def maxProfit(prices):
	# инициализируем левый и правый указатели
	l, r = 0, 1
	# инициализируем переменную максимальной выгоды и устанавливаем ее нулем
	maxP = 0

	while r != len(prices):
		# проверяем значения цен. Если левое значение больше правого, то такой формат не интересен, пропускаем его и переходим к else
		if prices[l] < prices[r]:
			prof = prices[r] - prices[l]
			# если prof больше, чем maxP, обновляем maxP
			maxP = max(maxP, prof)
		else:
			# сдвигаем левый указатель до правого
			l = r
		# сдвигаем правый указатель на единицу
		r += 1
	return maxP
```