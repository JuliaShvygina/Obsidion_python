### Вступление
Рассмотрим процессы, которые происходят в питон под капотом. А именно:

* поговорим о разнице между интерпретируемыми и компилируемыми языками
* посмотрим на питоновский байткод и еще раз обратимся к модулю dis
* обсудим с тобой что происходит после преобразования кода в байткод
* поговорим немного о том, что такое память и в чем разница между stack и heap

### Интерпретируемые и компилируемые языки
> знаешь ли ты в чем разница между этими двумя понятиями? Можешь ли назвать парочку языков из одного и из второго типа?

**Компилируемыми** языками называют те, языки, код которых будет преобразован из человекочитаемого в машинный. То есть в тот, который ясен компьютеру, а именно железу.
Ярким примером такого языка является С. Ниже я приведу тебе пример того как это происходит:

1. Напишем вывод Hello World в консоль на Си
```C
#include <stdio.h>
int main() {
// printf() displays the string inside quotation
printf("Hello, World!");
return 0;
}
```
2. скомпилируем его в машинный код
```C
gcc -Wall -Wextra -Werror abc.c 
```

если у тебя нет gcc его можно установить через apt-get
3. попробуем посмотреть что внутри файла
```
cat a.out
```
Вот что у меня получилось:
[вывод](https://imgur.com/i9x9QXX)
выглядит страшновато, лишь местами проскальзывают какие-то понятные слова. Это потому что это машинный код, который не предназначен для чтения человеком.

> Плюсы компилируемых языков в том, что после компиляции машина сразу получает удобную для нее форму записи, которую быстро прочитает - поэтому скорость - основное преимущество таких языков.

**Интерпретируемые** языки - иного плана. Между машинным кодом и кодом, который написал человек, есть прослойка в виде виртуальной машины, которая:

* читает код построчно, а не целиком весь файл
* переводит код в байткод (об этом подробнее чуть дальше)
* переводит байт код в машинный код

Может возникнуть вопрос, зачем эта прослойка в виде байткода? В чем преимущество? Ведь очевидно, что раз есть лишние операции, то и время работы возрастет.
Дело в том, что компилируемые языки, очень сильно зависят от машины на которой воспроизводятся. Появляется новый процессор - надо писать под него настройку компиляции. Кроме того *в компилируемых языках невозможна динамическая типизация*, то есть переменная при объявлении сразу имеет свой тип, например int.
В интерпретируемых языках все это возможно.

### Виртуальная машина Python и байткод
Рассмотрим теперь процессы, которые происходят непосредственно в питоне, когда мы выполняем:
```
python abc.py
```

#### Этап первый: Инициализация самого питона
Как ты наверное слышала, питон написан на Си. Также он открытый язык. Это значит, что он лежит на гите и каждый может принять участие в разработке новой версии.
Вот ссылка не репозиторий, можно принять участие)) [ссылка](https://github.com/python/cpython) Питон строит дерево своих библиотек, смотрит версию, готовит внутренние объекты и так далее. Нам это не особенно интересно, потому что это не затрагивает пока что работу с нашей программой.

#### Этап второй: Проверка нет ли .pyc файла и его версии
После того, как питон запустился, ему надо выполнить твою программу. Он считывает название файла, и затем проверяем, есть ли в папке _pycache_ уже скомпилированный файл для данного куска кода. Да-да, все верно, тут нет противоречий, пайтон тоже компилирует свои файлы в машинный код, просто это делает Си, на котором написан пайтон)).
Для маленьких программ Пайтон не делает кеша, потому что так эффективнее. Но мы можем насильно вызвать это поведение. Давай скомпилируем наш прекрасный файлик abc.py в машинный код:
```
python -m compileall abc.py
```
После этой операции у тебя в папке должна была появиться папка **pycache** в которой должен был появиться файл abc.pyc. Проверь. Если мы сейчас воспользуемся утилитой cat как в случае с си, то увидим примерно такой же результат - нечитаемую фигню с вкраплениями понятных слов.
Пример как это выглядит у меня: [ссылка](https://i.imgur.com/JxOQDvC.png)
Поэтому когда ты видишь в корневой папке своего проекта папку **pycache** знай, что питон пытается прекомпилировать сложные файлы с большим количеством логики, чтобы потом не производить эту компиляцию повторно и ускорить выполнение операции. Таким образом на этом этапе, питон проверяет, есть ли .pyc файл и не устарел ли он. Если не устарел, то использует его вместо твоего кода, тем самым пропуская этап проверки синтаксиса и компиляции байткода.

#### Этап третий: Проверка синтаксиса
Допустим, что .pyc файла нет, тогда питон произоводит построчное чтение твоего скрипта и проверяет, соблюдены ли все синтаксические правила. Если не соблюдены, то сразу выкидывается исключение. Если ок, то происходит построение дерева вызовово и преобразование в байткод.

#### Этап четвертый: Построение дерева вызовов и создание байткода
После того, как питон убеждается, что синтаксис файла корректный, он начинает строить дерево вызовов. Например в основном пространстве main.py происходит вызов функции print(), которая вызывает другую функцию итд... На основе этого дерева, питон начинает создавать стек байткод операций.

> рекламная пауза, можешь ли ты сказать мне что такое стек?

**[[стек]]** - это структура данных, похожая на стопку тарелок, ты не можешь вытащить сразу нижнюю тарелку, иначе вся пирамида рассыпется. First in -last out.
Хорошо иллюстрирует данное поведение следующая картинка

Давай же посмотрим на этот байткод. На самой первой лекции Диман рассказывал нам о модуле dis, который позволяет нам увидеть на практике байткод операции и посмотреть как же интерпретирует наш код Питон.
Напишем простую функцию, которая просто принтин hello world.
```py
def hello():
    print("Hello, World!")

import dis
dis.dis(hello)
  2           0 LOAD_GLOBAL              0 (print)
              2 LOAD_CONST               1 ('Hello, World!')
              4 CALL_FUNCTION            1
              6 POP_TOP
              8 LOAD_CONST               0 (None)
             10 RETURN_VALUE
```
Прежде чем мы перейдем к разбору байткода, я хотел бы упомянуть еще об одной вещи, которая будет способствовать пониманию материала. Питон уже создал для нас объект для нашей потрясающей функции hello(), более того, мы даже можем посмотреть на это объект и на его атрибуты:
```py
dir(hello.__code__)  # раскомментируй меня.
hello.__code__.co_names
('print',)
```
Из всего многообразия нас интересуют несколько атрибтов:

* hello._code_.co_consts - это кортеж всех констант, которые встречаются в нашей функции. Какая тут есть константа?
* hello._code_.co_varnames - это кортеж всех локальных переменных, которые есть внутри функции.
* hello._code_.co_names - это кортеж всех всех нелокальных имен, которые использовались в функции.
* hello._code_.co_code - а это байткод, который ты видела выше - правда в виде байтов.
Теперь когда мы посмотрели на то, как как устроен объект кода функции, вернемся к байткоду.

* LOAD_GLOBAL 0 говорит питону попытаться найти объект с нулевым индексом в кортеже co_names, который является фуункцией какой? и запушить ее в стек в первую очередь
* LOAD_CONST 1 берет константу с индексом 1 в кортеже co_consts, которая является фразой "Hello, World!" и пушит в стек
* CALL_FUNCTION 1 говорит питону вызвать функцию функцию и говорит сколько позиций со стека нужно вызово нужновыкинуть, чтобы найти объект этой функции.
* POP_TOP - выкидывает константу Hello, World! из стека, теперь верхняя строчка на стеке вызовов это функция print
* LOAD_CONST загружает None константу потому что принт ничего не возвращает
* RETURN_VALUE возвращает значение.
Это примерно как это работает, к сожалению о самом процессе работы не очень много информации.

#### Этап пятый: Преобразование в машинный код
После того, как получен такой вот список байткод операций, питон просто компилирует байты в машинный код и потом исполняет его.

После того, как ты станешь большой и сильной, ты можешь почитать вот эту статью, где интерпретатор питона пишется на самом питоне)

### Отступление про Stack и Heap
Раз уж мы заговорили про операции с памятью и так далее, упомяну также про стек и кучу. Фактически, когда операционная система выделяет память на какой-то процесс - она выделяет ее не всю. По умолчанию для unix систем выделяется 8 мегабайт. Данную инфрмацию легко проверить если воспользоваться утилитой

ulimit -s
То есть когда ты запускаешь свою пайтон программу изначально выделяется 8 мегабайт оперативной памяти. Именно эта память являет собой и стек и кучу.

ошибкой будет думать что стек и куча - это разные объекты памяти. Нет, это всего лишь разные ее области в рамках выделенных 8 мегабайт.

Я всегда представляю для себя памяь примерно вот [так](https://i.imgur.com/W66wwDJ.png. Стек расположен ниже, а куча выше. Изначально программа пытается выделять память под все переменные в стеке если это возможно. Допустим мы объявляем переменную r = 1 - это неизменяемая переменная, так как это число. Значит виртуальная машина питона посмотрит, какая последняя ячейка памяти заполнена в стеке, и после нее аллокирует память размером, под целочисленное значение и положит туда единичку и ссылку на имя r.

Теперь представим, что r стала равна 2, что произойдет? Выделится следующий участок памяти, туда положится значение два и прилинкуется имя r, но ведь у r уже есть ссылка верно? Как думешь, что будет дальше?

Дальше, интерпретатор питона найдет более старую ссылк и удалит ее, а потом, он очистит память ячейки памяти, где хранилась единица, потому что в ней уже не будет ссылок.

Вроде все логично и просто, но только для значений размер которых известен заранее. То есть для неизменяемых типов. А что делать если тип данных изменяется в ходе работы программы? Например это список? В этом случае память под новый элемент аллокируется из верхней части памяти, то есть из кучи, потому что там память с большей вероятностью свободна. Это не очень удобно, потому что мы не можем подряд пройтись по ячейкам памяти и забрать все значения. В списках каждый элемент знает ссылку на последующий элемент,но не на предыдущий. Таким образом когда мы перебираем список, мы ходим по ссылкам и ищем нужную ячейку памяти.
А когда ходим скажем по строке, то перебираем ячейки памяти просто инрементом на 1, что быстрее.
```py
%timeit '[x for x in "abchgasklgdha;sdgh;asgha;sohg;asodghaidhgasd;lghasdliguhalsigh;bnbvnlag"]'
7.46 ns ± 0.869 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)

%timeit "[x for x in ['a', 'b', 'c', 'h', 'g', 'a', 's', 'k', 'l', 'g', 'd', 'h', 'a', ';', 's', 'd', 'g', 'h', ';', 'a', 's', 'g', 'h', 'a', ';', 's', 'o', 'h', 'g', ';', 'a', 's', 'o', 'd', 'g', 'h', 'a', 'i', 'd', 'h', 'g', 'a', 's', 'd', ';', 'l', 'g', 'h', 'a', 's', 'd', 'l', 'i', 'g', 'u', 'h', 'a', 'l', 's', 'i', 'g', 'h', ';', 'b', 'n', 'b', 'v', 'n', 'l', 'a', 'g']"
8.04 ns ± 0.092 ns per loop (mean ± std. dev. of 7 runs, 100000000 loops each)
все)
```
