---
aliases: []
---
```py

```

## Индексы базы данных
Простейший метод решения задачи поиска записей в базе данных, удовлетворяющих определенному критерию, — **полный перебор**. Но с ростом количества записей производительность такого подхода будет заметно падать. Для повышения производительности поиска создаются вспомогательные структуры — **_индексы_**. Используя индексы, можно существенно поднять скорость поиска, потому что данные в индексе хранятся в форме, позволяющей нам в процессе поиска не рассматривать области, которые заведомо не могут содержать искомые элементы.
Принцип работы одного из важнейших индексов в базе данных (индекс на основе B-дерева) основан именно на рассмотренном нами выше принципе — **возможности хранить данные в отсортированном виде**.

**Индекс** – это набор ссылок, упорядоченных по определенному столбцу таблицы, который в данном случае будет называться индексированным столбцом. Хотя индекс и связан с конкретным столбцом (или столбцами) таблицы, все же он является самостоятельным объектом базы данных.

Индекс
*  структура данных, позволяющая быстро определить положение интересующих данных в базе
*  создается для столбца (совокупности столбцов) в таблице
*  обеспечивает возможность повысить производительносчть запросов

![](https://i.imgur.com/1Rk2peR.png)

```sql
CREATE INDEX название.таблицы_название.столбца_idx
ON название таблицы(название столбца порядок.сортировки)

```

**INDEXING** — это метод структуры данных, который позволяет вам быстро извлекать записи из файла базы данных. Индекс — это небольшая **таблица**, имеющая всего два столбца. Первый столбец содержит копию первичного или потенциального ключа таблицы. Его второй столбец содержит набор указателей для хранения адреса дискового блока, где хранится это конкретное значение ключа.

Индекс —
-   Принимает ключ поиска в качестве ввода
-   Эффективно возвращает коллекцию совпадающих записей.

#### Структура индекса

Индексы создаются для столбцов таблиц и представлений. Индексы предоставляют путь для быстрого поиска данных на основе значений в этих столбцах. 
Например, если вы создадите индекс по первичному ключу, а затем будете искать строку с данными, используя значения первичного ключа, то _SQL Server_ сначала найдет значение индекса, а затем использует индекс для быстрого нахождения всей строки с данными. Без индекса будет выполнен полный просмотр (сканирование) всех строк таблицы, что может оказать значительное влияние на производительность.

Индекс состоит из набора страниц, узлов индекса, которые организованы в виде древовидной структуры — _сбалансированного дерева_. Эта структура является иерархической по своей природе и начинается с корневого узла на вершине иерархии и конечных узлов, листьев, в нижней части, как показано на рисунке:
![](https://habrastorage.org/r/w1560/getpro/habr/post_images/e35/b8e/5a8/e35b8e5a8538064b22082a4e5351574a.jpg)

Когда вы формируете запрос на индексированный столбец, подсистема запросов начинает идти сверху от корневого узла и постепенно двигается вниз через промежуточные узлы, при этом каждый слой промежуточного уровня содержит более детальную информацию о данных. Подсистема запросов продолжает двигаться по узлам индекса до тех пор, пока не достигнет нижнего уровня с листьями индекса. 
К примеру, если вы ищете значение 123 в индексированном столбе, то подсистема запросов сначала на корневом уровне определит страницу на первом промежуточном (intermediate) уровне. В данном случае первой страница указывает на значение от 1 до 100, а вторая от 101 до 200, таким образом подсистема запросов обратится ко второй странице этого промежуточного уровня. Далее будет выяснено, что следует обратиться к третьей странице следующего промежуточного уровня. Отсюда подсистема запросов прочитает на нижнем уровне значение самого индекса. Листья индекса могут содержать как сами данные таблицы, так и просто указатель на строки с данными в таблице, в зависимости от типа индекса: кластеризованный индекс или некластеризованный.

### Селективность индекса

Чем меньшему количеству строк соответсвует значение атрибута, тем выше селективность. Такие атрибуты следует использовать в начале индекса:
![](https://i.imgur.com/HEAePiS.png)


Пример.
Есть таблица продуктов с 6 000 000 записей. Как оптимизировать поиск?
Если искать товар по таблице, то поиск будет идти последовательно, это долго.
1. Можно сделать индекс по вендору, т.к. вендоров меньше, чем товаров.
При этом у нас формируется таблица индексов, с ключами - названиями вендоров, значениям - соответсвующими им значениями строк исходной таблицы.
2. Более того, в индексах поиск идет не по целой строке запроса, а посимвольно:
![](https://i.imgur.com/PkVw35j.png)
3. При этом поиск символа тоже идет нелинейно. Сперва сортируется массив. А затем осуществляется бинарный поиск:
![](https://i.imgur.com/Y312Zpr.png)
и так по каждой позиции.

## Групповые индексы
Для запросов, в которых используется несколько колонок, необходимо использовать **составные индексы**.
![](https://i.onthe.io/smngoz79t006u56ci.7dc9f1ef.jpg)
Чтобы правильно использовать составные индексы, необходимо понять структуру их хранения. Все работает точно так же, как и для обычного индекса. Но для значений используются значения всех входящих колонок сразу. Для таблицы с такими данными:

id | name   | age | gender
1  | Den    | 29 | male
2  | Alyona | 15 | female
3  | Putin  | 89 | tsar
4  | Petro  | 12 | male

значения составного индекса будут такими:

age_gender
12male
15female
29male
89tsar

#### Поиск по диапазону

Представим, что наш запрос будет использовать не сравнение, а поиск по диапазону:
```sql
SELECT * FROM users WHERE age <= 29 AND gender = 'male'
```

Тогда MySQL не сможет использовать полный индекс, т.к. значения gender будут отличаться для разных значений колонки age. В этом случае база данных попытается использовать часть индекса (только age), чтобы выполнить этот запрос:

age_gender
12male
15female
29male
89tsar

Сначала будут отфильтрованы все данные, которые подходят под условие age <= 29. Затем, поиск по значению “male” будет произведен без использования индекса.

### Использование EXPLAIN для анализа индексов

Инструкция EXPLAIN покажет данные об использовании индексов для конкретного запроса. Например:
```sql
mysql> EXPLAIN SELECT * FROM users WHERE email = 'golotyuk@gmail.com';
```

![](https://highload.today/wp-content/uploads/2019/11/Screenshot-2021-03-19-at-11.29.00-1024x111.png)

**key** показывает используемый индекс
**possible_keys** показывает все индексы, которые могут быть использованы для этого запроса
**rows** показывает число записей, которые пришлось прочитать базе данных для выполнения этого запроса

Как видим, в примере не используется ни один индекс. После создания индекса:
```sql
mysql> EXPLAIN SELECT * FROM users WHERE email = 'golotyuk@gmail.com';
```

![](https://highload.today/wp-content/uploads/2019/11/Screenshot-2021-03-19-at-11.30.44-1024x109.png)

Прочитана всего одна запись, так как был использован индекс.

Explain также поможет определить правильность использования составного индекса.


## Транзакции
Транзакция — последовательность команд, которые должны быть выполнены полностью или не выполнены вообще.

Почему такая проблема может возникнуть?
- Отказ СУБД
- Отказ приложения пользователя
- Потеря сетевого соединения клиента и сервера СУБД
Пример:
![](https://i.imgur.com/uCd8Inn.png)

Для начала работы с транзакцией необходимо ввести ключевое слово:

```sql
START TRANSACTION;

UPDATE accounts SET balance = balance - 15000
WHERE account_number = 1234567;

UPDATE accounts SET balance = balance + 15000
WHERE account_number = 9876543;

COMMIT;  // для записи изменений в базу данных
ROLLBACK; // для отката всех изменений

```

Многие СУБД сейчас используют автоматическую фиксацию транзакций.

